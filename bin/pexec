#!/usr/bin/perl -w

#
#  ###################################################################
#
#  Disclaimer and Notice of Copyright 
#  ==================================
#
#  Copyright (c) 2007, Los Alamos National Security, LLC
#  All rights reserved.
#
#  Copyright 2007. Los Alamos National Security, LLC. 
#  This software was produced under U.S. Government contract 
#  DE-AC52-06NA25396 for Los Alamos National Laboratory (LANL), 
#  which is operated by Los Alamos National Security, LLC for 
#  the U.S. Department of Energy. The U.S. Government has rights 
#  to use, reproduce, and distribute this software.  NEITHER 
#  THE GOVERNMENT NOR LOS ALAMOS NATIONAL SECURITY, LLC MAKES 
#  ANY WARRANTY, EXPRESS OR IMPLIED, OR ASSUMES ANY LIABILITY 
#  FOR THE USE OF THIS SOFTWARE.  If software is modified to 
#  produce derivative works, such modified software should be 
#  clearly marked, so as not to confuse it with the version 
#  available from LANL.
#
#  Additionally, redistribution and use in source and binary 
#  forms, with or without modification, are permitted provided 
#  that the following conditions are met:
#  -  Redistributions of source code must retain the 
#     above copyright notice, this list of conditions 
#     and the following disclaimer. 
#  -  Redistributions in binary form must reproduce the 
#     above copyright notice, this list of conditions 
#     and the following disclaimer in the documentation 
#     and/or other materials provided with the distribution. 
#  -  Neither the name of Los Alamos National Security, LLC, 
#     Los Alamos National Laboratory, LANL, the U.S. Government, 
#     nor the names of its contributors may be used to endorse 
#     or promote products derived from this software without 
#     specific prior written permission.
#   
#  THIS SOFTWARE IS PROVIDED BY LOS ALAMOS NATIONAL SECURITY, LLC 
#  AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, 
#  INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF 
#  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. 
#  IN NO EVENT SHALL LOS ALAMOS NATIONAL SECURITY, LLC OR CONTRIBUTORS 
#  BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, 
#  OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, 
#  PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, 
#  OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY 
#  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR 
#  TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT 
#  OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY 
#  OF SUCH DAMAGE.
#
#  ###################################################################


$| = 1;
($prog = $0) =~ s!.*/!!;

$PMAX = 32;

use Fcntl qw(:DEFAULT :flock);

use Pod::Usage;
use Getopt::Long;
&Getopt::Long::config(
   'require_order',			# don't mix non-options with options
   'auto_abbrev',			# allow unique option abbreviation
   'bundling',				# allow bundling of options
);

use Sys::Hostname;
our $ThisMachine = hostname;
$ThisMachine =~ s/\..*//;

our $prompt = $ENV{'prompt'} || '# ';

unshift (@ARGV, split(/\s+/, $ENV{'PEXEC'})) if (exists $ENV{'PEXEC'});

local (
   $opt_a,				# all
   $opt_bpsh,				# bpsh remote
   $opt_bpcp,				# bpcp to remote
   $opt_debug,				# debug
   $opt_fanout,				# remote-copy fan-out
   $opt_h,				# help
   $opt_l,				# login
   @opt_m,				# machines
   $opt_man,				# man page
   $opt_output,				# output file (default: STDOUT)
   $opt_P,				# parallel
   $opt_p,				# prefix
   $opt_rand,				# randomize host list
   $opt_rcp,				# rcp to remote
   $opt_opts,				# remote copy program options
   $opt_rsh,				# rsh remote
   $opt_rsync,				# rsync to remote
   $opt_rsync_rsh,			# rsync remote transport shell
   @opt_s,				# skip
   $opt_scp,				# scp to remote
   $opt_ssh,				# ssh remote
   $opt_success,			# successful exit statuses
   $opt_t,				# timeout
   $opt_v,				# verbose
   $opt_V				# verify
);
$opt_fanout = 256;
$opt_t=300;				# timeout
$opt_success='0';			# successful exit statuses
$opt_output='-';			# output file (default: STDOUT)

pod2usage(2) unless &GetOptions(
   'a|all'		=> \$opt_a,
   'bpsh'		=> \$opt_bpsh,
   'bpcp'		=> \$opt_bpcp,
   'bpcp-opts=s'	=> \$opt_opts,
   'd|debug'		=> \$opt_debug,
   'exit-success=s'	=> \$opt_success,
   'fan-out=i'		=> \$opt_fanout,
   'h|help'		=> \$opt_h,
   'l|login=s'		=> \$opt_l,
   'm|machines=s'	=> \@opt_m,
   'man'		=> \$opt_man,
   'o|output=s'		=> \$opt_output,
   'P|parallel:i'	=> \$opt_P,
   'p|prefix'		=> \$opt_p,
   'random'		=> \$opt_rand,
   'rcp'		=> \$opt_rcp,
   'rcp-opts=s'		=> \$opt_opts,
   'rsh'		=> \$opt_rsh,
   'rsync'		=> \$opt_rsync,
   'rsync-opts=s'	=> \$opt_opts,
   'rsync-rsh=s'	=> \$opt_rsync_rsh,
   's|skip=s'		=> \@opt_s,
   'scp'		=> \$opt_scp,
   'scp-opts=s'		=> \$opt_opts,
   'ssh'		=> \$opt_ssh,
   't|timeout=i'	=> \$opt_t,
   'v|verbose'		=> \$opt_v,
   'V|verify'		=> \$opt_V,
);

pod2usage(1) if (defined($opt_h));
if ($opt_man) {				# print the man page
   $ENV{'LANG'} = 'C';
   if ($< && $>) {			# no root privs
      pod2usage(-verbose => 2);
   } else {
      my $id = getpwnam("nobody") || getpwnam("nouser") || -2;
      eval {
	 $> = $id;			# drop euid first
	 $< = $id;			# drop ruid
      };
      if (!$@ && $< && $>) {		# success!
	 pod2usage(-verbose => 2)
      } else {				# failure!
	 pod2usage(1);
      }
   }
}

pod2usage(qq|$prog: option '-l' cannot be used with without '--rsh' or '--ssh'!|)
   if (defined($opt_l) && !(defined($opt_rsh) || defined($opt_ssh)));
pod2usage(qq|$prog: option '--rsh' cannot be used with option '--ssh'|) if
   (defined($opt_rsh) && defined($opt_ssh));
pod2usage(qq|$prog: option '--rsh' cannot be used with option '--bpsh'|) if
   (defined($opt_rsh) && defined($opt_bpsh));
pod2usage(qq|$prog: option '--ssh' cannot be used with option '--bpsh'|) if
   (defined($opt_ssh) && defined($opt_bpsh));
pod2usage(qq|$prog: option '--rsync-rsh' can only be used with option '--rsync'|) if
   (defined($opt_rsync_rsh) && ! defined($opt_rsync));
pod2usage(qq|$prog: option '--fan-out' must be non-negative!|)
   unless ($opt_fanout >= 0);

my @bpcp_opts  = ('-rp');		# default bpcp options
my @rcp_opts   = ('-rp');		# default rcp options
my @rsync_opts = ('-aq');		# default rsync options
my @scp_opts   = ('-Brpq');		# default scp options

our $opt_rcpy = undef;
our @opt_rcpy_opts = split(/\s+/, $opt_opts) if (defined($opt_opts));
if (defined($opt_rcp)) {
   pod2usage(qq|$prog: option '--rcp' cannot be used with option '--scp'|)
      if (defined($opt_scp));
   pod2usage(qq|$prog: option '--rcp' cannot be used with option '--bpcp'|)
      if (defined($opt_bpcp));
   pod2usage(qq|$prog: option '--rcp' cannot be used with option '--rsync'|)
      if (defined($opt_rsync));
   $opt_rcpy = 'rcp';
   @opt_rcpy_opts = @rcp_opts unless(@opt_rcpy_opts);
} elsif (defined($opt_scp)) {
   pod2usage(qq|$prog: option '--scp' cannot be used with option '--bpcp'|)
      if (defined($opt_bpcp));
   pod2usage(qq|$prog: option '--scp' cannot be used with option '--rsync'|)
      if (defined($opt_rsync));
   $opt_rcpy = 'scp';
   @opt_rcpy_opts = @scp_opts unless(@opt_rcpy_opts);
} elsif (defined($opt_bpcp)) {
   pod2usage(qq|$prog: option '--bpcp' cannot be used with option '--rsync'|)
      if (defined($opt_rsync));
   $opt_rcpy = 'bpcp';
   @opt_rcpy_opts = @bpcp_opts unless(@opt_rcpy_opts);
} elsif (defined($opt_rsync)) {
   $opt_rcpy = 'rsync';
   @opt_rcpy_opts = @rsync_opts unless(@opt_rcpy_opts);
   pod2usage(qq|$prog: option '--rsync-opts' may not contain '-e' or '--rsh'|)
      if (grep(/(-e|--rsh)\s+\S+/, @opt_rcpy_opts));
   $opt_rsync_rsh = 'ssh -qx' unless (defined($opt_rsync_rsh));
   push(@opt_rcpy_opts, '-e', $opt_rsync_rsh);
}

$opt_output = '-' if defined($opt_rcpy);	# copy cmds always send to STDOUT

# redefine success
our %EXIT_success = ();
if (defined($opt_success)) {
   foreach my $status (split(',', $opt_success)) {
      pod2usage(qq|$prog: --exit-success: '$status' must be numeric|)
	 unless ($status =~ /^\d+$/);
      $EXIT_success{$status}++;
   }
} else {
   $EXIT_success{'0'}++;
}

unless (@ARGV) {
   pod2usage("$prog: no cmd specified!");
}

our @ARGTree = ();			# ARGV for the tree
if (defined($opt_rcpy)) {
   pod2usage("$prog: option '--$opt_rcpy': too few arguments")
      unless (scalar @ARGV >= 2);

   my @RLP = ($opt_rcpy, @opt_rcpy_opts);

   our $strand = '';			# a random string a user will never
   my @Chars = ('a'..'z','A'..'Z','0'..'9','_');	# use as a 'dest'!
   foreach (1 .. 32) {
      $strand .= $Chars[rand @Chars];
   }

   my $dst_host = $dst_path = $dst_file = undef;
   my $dst = $ARGV[-1];			# dest is always the last arg
   my $dst_d = 0;			# assume dest isn't a dirname

   pod2usage("$prog: option '--$opt_rcpy': invalid dest description: $dst")
      unless ($dst =~ /\%host\%:/);

   pod2usage("$prog: option '--$opt_rcpy': internal error: $dst")
      if ($dst =~ /\%$strand\%/);

   if ($dst =~ /^(\S+):(.*)\/(\S+)$/) {	# ^dst_host:dst_path/dst_file$
      $dst_host = $1;
      $dst_path = $2;
      $dst_file = $3;
   }

   (my $server = $dst_host) =~ s/\%host\%/\%$strand\%/ig;

   if (scalar @ARGV > 2) {		# multiple src must go to a directory
      $dst_d = 1;
   } elsif ($dst_file eq '.') {		# a trailing "/."
      $dst_d = 1;
   } elsif ($dst_file =~ /\/$/) {	# a trailing "/"
      $dst_path .= "/$dst_file" ;
      $dst_file = '.';
      $dst_d = 1;
   } elsif (-d "$dst_path/$dst_file"	# a hint from local disk -
      && $dst_file ne '.') {		# this could be problematic
      $dst_d = 1;			# if the remote disk doesn't
   }					# mimick the execution host's

   grep($_ =~ s/\/+/\//g,@ARGV);	# strip duplicate slashes

   for (my $i = 0; $i < $#ARGV; $i++) {
      my $src = $ARGV[$i];
      -r $src || die "$prog: $src: $!\n";

      my $src_path = $src_file = undef;

      if ($src =~ /^(.*)\/(\S+)$/) {	# ^src_path/src_file$
	 $src_path = $1;
	 $src_file = $2;
      } else {
	 $src_path = '.';
	 $src_file = $src;
      }

      if (defined($opt_rsync)) {
	 if ($src_file =~ /\/$/ && -d "$src_path/$src_file") {	# src/
	    chop $src_file;		# trim trailing "/"
	    opendir(SRC, "$src_path/$src_file")
	       || die "$prog: $src_path/$src_file: $!\n";
	    foreach my $file (grep { $_ !~ /^\.{1,2}$/ } readdir(SRC)) {
	       push(@ARGTree, "$dst_path/$dst_file/$file");
	    }
	    closedir(SRC);
	 } else {
	    push(@ARGTree, $dst_d
	       ? "$dst_path/$dst_file/$src_file"
	       : "$dst_path/$dst_file"
	    );
	 }
      } elsif (defined($opt_scp)) {
	 push(@ARGTree, $dst_d
	    ? "$dst_path/$dst_file/$src_file"
	    : "$dst_path/$dst_file"
	 );
      } else {
	 push(@ARGTree, $dst_d
	    ? "$server:$dst_path/$dst_file/$src_file"
	    : "$server:$dst_path/$dst_file"
	 );
      }
   }
   push (@ARGTree, $ARGV[-1]);

   if (defined($opt_rsync)) {		# remote copy by rsync-rsh
      unshift (@ARGTree, split(/\s+/, "$opt_rsync_rsh $server"), @RLP);
   } elsif (defined($opt_scp)) {	# remote copy by ssh
      unshift (@ARGTree, split(/\s+/, "ssh -qnx $server"), @RLP);
   } else {
      unshift (@ARGTree,@RLP);		# 3rd party copy
   }

   grep($_ =~ s/\/+/\//g,@ARGTree);	# strip duplicate slashes

   unshift (@ARGV,@RLP);
}

if (defined($opt_rsh)) {
   my @RLP = (defined($opt_l) ?
      ('rsh','-n',"$opt_l\@%host%") :
      ('rsh','-n','%host%')
     );
   unshift (@ARGV,@RLP);
}

if (defined($opt_ssh)) {
   my @RLP = (defined($opt_l) ?
      ('ssh','-nx',"$opt_l\@%host%") :
      ('ssh','-nx','%host%')
     );
   unshift (@ARGV,@RLP);
}

if (defined($opt_bpsh)) {
   my @RLP = ('bpsh','-n','%host%');
   unshift (@ARGV,@RLP);
}

if (defined($opt_P)) {
   if (defined($opt_rcpy)) {
      $opt_P = 1 unless $opt_P;		# default rcpy arity = 1
   } else {
      $opt_P = $PMAX unless $opt_P;
   }
} else {
   $opt_P = 1;
}

unless (@opt_m) {
   pod2usage("$prog: no machine group specified!");
}

our %NETGROUP = ();
&CacheNetgroups(\%NETGROUP);
our @MachineList = &GetMachines(\%NETGROUP,\@opt_m);
our @MachineSkip = &GetMachines(\%NETGROUP,\@opt_s) if (@opt_s);
push(@MachineSkip,$ThisMachine) unless (defined($opt_a));

foreach $skip (@MachineSkip) {
   @MachineList = grep(! /^\Q$skip\E$/,@MachineList);
}

unless (@MachineList) {
   print STDERR "$prog: empty machine group!\n" if ($opt_v);
   exit 0;
}

use POSIX qw(tmpnam);
do { $tty = tmpnam() }
   until sysopen(TTY, $tty, O_RDWR|O_EXCL|O_CREAT); 

print STDERR "Timeout: $opt_t seconds.\n" if ($opt_v && $opt_t);

# Exec the command
our @WorkQ = ();
our %RUNpids = %RC = ();
local $SIG{'QUIT'} = 'IGNORE';
local $SIG{'INT'} = local $SIG{'TERM'} = \&IT_signal_handler;
local $SIG{'TSTP'} = \&tstp_signal_handler; local $SIGTSTP = 0;
local $SIG{'__DIE__'} = \&__DIE__signal_handler;

H: while (@MachineList) {
   my $running = 0;
   foreach (values %RUNpids) { $running++ unless defined $_->{'sender'}; }
   if ($running < abs($opt_P)) {
      my $machine = ($opt_rand
	 ? splice(@MachineList,int(rand(scalar @MachineList)),1)
	 : shift(@MachineList)
      );
      if ( my $pid = &spawn($machine) ) {
	 $RUNpids{$pid} = {
	    'sender'	=> undef,	# a root process
	    'machine'	=> $machine,
	 };
      }
      next H;
   }

   while (@WorkQ) {
      last unless (@MachineList);
      last unless ( scalar keys %RUNpids < $opt_fanout );
      my $sender = shift(@WorkQ);
      my $machine = ($opt_rand
	 ? splice(@MachineList,int(rand(scalar @MachineList)),1)
	 : shift(@MachineList)
      );
      if ( my $pid = &tspawn($sender,$machine) ) {
	 $RUNpids{$pid} = {
	    'sender'	=> $sender,	# a tree process
	    'machine'	=> $machine,
	 };
      }
   }

   my $WQ = &ReapChildren(\%RUNpids,\%RC);

   if (defined($opt_rcpy) && scalar(@{ $WQ })) { 
      push (@WorkQ, @{ $WQ });
      $opt_P = 0 unless ($opt_P > 0);
   }

   &handle_sigTSTP if ($SIGTSTP);
}

while ( %RUNpids ) {
   &ReapChildren(\%RUNpids,\%RC);
   &handle_sigTSTP if ($SIGTSTP);
}

if (-e $tty) {
   unlink($tty) || die "$prog: unable to unlink $tty: $!\n";
}

my $status = 0;
foreach my $failed (keys %RC) {
   $status |= $RC{$failed};		# OR the non-successful exit statuses
}

exit $status;

sub tspawn ($$) {
   my ($sender,$machine) = @_;

   my $pid;
   my @Cmd = (scalar @ARGTree ? @ARGTree : @ARGV);

   grep($_ =~ s/\%$strand\%/$sender/ig,@Cmd);
   grep($_ =~ s/\%host\%/$machine/ig,@Cmd);
   my $cmd = join(' ',@Cmd);

   if ( $pid = fork ) {				# parent
      return $pid;
   } elsif ( defined $pid ) {			# child
      local $SIG{'TSTP'} = 'IGNORE';
      local $SIG{'__DIE__'} = 'DEFAULT';
      local $SIG{'INT'} = local $SIG{'TERM'} = local $SIG{'QUIT'} = sub {
	 if (defined($cpid)) {
	    kill 9,$cpid;
	    close(CMD);
	 }
	 die " '$cmd': killed.\n";
      };
      local $SIG{'ALRM'} = sub {
	 if (defined($cpid)) {
	    kill 9,$cpid;
	    close(CMD);
	 }
	 die " '$cmd': command timed out ($opt_t sec)\n";
      };

      my $rc = 0;

      alarm($opt_t);
      unless (defined($cpid = 
	 open(CMD, "-|"))) {
	    die " '$cmd': failed.\n";
      }

      unless ($cpid) {				# grandchild
	 open(STDERR, ">&STDOUT");		# dup STDOUT
	 if (defined($opt_debug)) {
	    print join(" ", map { qq|'$_'| } @Cmd) . "\n";
	    sleep 1;
	    exit 0;
	 } else {
	    exec { $Cmd[0] } @Cmd;
	    exit -1;
	 }
      }

      my @Output = <CMD>;
      unless (close CMD) {
	 $rc = $?>>8;
      }
      alarm(0);

      $| = 1;
      if (@Output) {
	 (my $host = $machine) =~ s/\..*//;
	 (my $server = $sender) =~ s/\..*//;
	 @Output = map { "$sender->$host: $_" } @Output if ($opt_p);
	 if ($opt_v) {
	    unshift(@Output, "$prompt$cmd\n");
	    push(@Output, "\n");
	 }
	 sysopen(TTY, $tty, O_RDONLY) ||
	    die "$prog: unable to open '$tty': $!\n";
	 die "$prog: flock failure: $!\n" unless flock(TTY, LOCK_EX);
	 print STDOUT (@Output);
	 close STDOUT;
	 flock(TTY, LOCK_UN);
	 close(TTY);
      } elsif ($opt_v) {			# no output produced by cmd
	 sysopen(TTY, $tty, O_RDONLY) ||
	    die "$prog: unable to open '$tty': $!\n";
	 die "$prog: flock failure: $!\n" unless flock(TTY, LOCK_EX);
	 print STDOUT "$prompt$cmd\n";
	 close STDOUT;
	 flock(TTY, LOCK_UN);
	 close(TTY);
      }
      exit $rc;
   } else {					# fork error
      warn "fork: $!\n";
      return 0;
   }
}

sub spawn ($) {
   my $machine = $_[0];

   my $pid;
   my @Cmd = @ARGV;
   grep($_ =~ s/\%host\%/$machine/ig,@Cmd);
   (my $outfile = $opt_output) =~ s/\%host\%/$machine/ig;
   my $cmd = join(' ',@Cmd);

   if ( $pid = fork ) {				# parent
      return $pid;
   } elsif ( defined $pid ) {			# child
      local $SIG{'TSTP'} = 'IGNORE';
      local $SIG{'__DIE__'} = 'DEFAULT';
      local $SIG{'INT'} = local $SIG{'TERM'} = local $SIG{'QUIT'} = sub {
	 if (defined($cpid)) {
	    kill 9,$cpid;
	    close(CMD);
	 }
	 die " '$cmd': killed.\n";
      };
      local $SIG{'ALRM'} = sub {
	 if (defined($cpid)) {
	    kill 9,$cpid;
	    close(CMD);
	 }
	 die " '$cmd': command timed out ($opt_t sec)\n";
      };

      my $rc = 0;

      alarm($opt_t);
      unless (defined($cpid = 
	 open(CMD, "-|"))) {
	    die " '$cmd': failed.\n";
      }

      unless ($cpid) {				# grandchild
	 open(STDERR, ">&STDOUT");		# dup STDOUT
	 if (defined($opt_debug)) {
	    print join(" ", map { qq|'$_'| } @Cmd) . "\n";
	    sleep 1;
	    exit 0;
	 } else {
	    exec { $Cmd[0] } @Cmd;
	    exit -1;
	 }
      }

      my @Output = <CMD>;
      unless (close CMD) {
	 $rc = $?>>8;
      }
      alarm(0);

      $| = 1;
      if (@Output) {
	 (my $host = $machine) =~ s/\..*//;
	 if ($opt_p) {				# prefix
	    @Output = defined $opt_rcpy
	       ? map { "$ThisMachine->$host: $_" } @Output
	       : map { "$host: $_" } @Output;
	 }
	 sysopen(TTY, $tty, O_RDONLY) ||
	    die "$prog: unable to open '$tty': $!\n";
	 die "$prog: flock failure: $!\n" unless flock(TTY, LOCK_EX);
	 open (OUTPUT, ">>$outfile") || die "$prog: unable to open '$outfile': $!\n";
	 print STDOUT "$prompt$cmd\n" if ($opt_v);
	 print OUTPUT (@Output);
	 print STDOUT "\n" if ($opt_v);
	 close OUTPUT;
	 flock(TTY, LOCK_UN);
	 close(TTY);
      } elsif ($opt_v) {			# no output produced by cmd
	 sysopen(TTY, $tty, O_RDONLY) ||
	    die "$prog: unable to open '$tty': $!\n";
	 die "$prog: flock failure: $!\n" unless flock(TTY, LOCK_EX);
	 print STDOUT "$prompt$cmd\n";
	 close STDOUT;
	 flock(TTY, LOCK_UN);
	 close(TTY);
      }
      exit $rc;
   } else {					# fork error
      warn "fork: $!\n";
      return 0;
   }
}

sub ReapChildren ($$) {
   my ($RUN_ref,$RC_ref) = @_;
   use POSIX ":sys_wait_h";
   my @RunQ = ();

   foreach my $pid (keys %$RUN_ref) {
      if ( waitpid($pid,&WNOHANG) > 0 ) {
	 my $rc = $?>>8;
	 if (exists($EXIT_success{$rc})) {	# success!
	    push(@RunQ, $RUN_ref->{$pid}{'machine'});
	 } else {				# failure!
	    $$RC_ref{$RUN_ref->{$pid}{'machine'}} = $rc;
	 }
	 if (defined($RUN_ref->{$pid}{'sender'})) {
	    push(@RunQ, $RUN_ref->{$pid}{'sender'});
	 }
	 delete $RUN_ref->{$pid};
      }
   }
   select(undef, undef, undef, 0.1);
   return \@RunQ;
}

sub CacheNetgroups ($) {
   my $href = $_[0];

   my %TMP = ();

   open(CFG,'/etc/netgroup') || return 0;
   while (defined(my $ngrent = <CFG>)) {
      next if ($ngrent =~ /^#/);		# strip out comments
      next if ($ngrent =~ /(\(|\))/);		# strip lines containing ( or )
      chomp $ngrent;
      my ($key, $value) = split(/\s+/, $ngrent, 2);
      $TMP{$key} = $value if (defined $value);
   }
   close CFG;

   foreach my $key (sort keys %TMP) {
      @{ $href->{$key}} = &ExpandNetgroup(\%TMP, $TMP{$key});
   }
}

sub ExpandNetgroup ($$) {
   my ($href, $values) = @_;

   return map { exists $href->{$_}
      ? &ExpandNetgroup($href, $href->{$_})		# netgroup indirection
      : $_ 
   } split /\s+/, $values;
}

sub GetMachines ($$) {
   my ($href,$aref) = @_;

   my @Machines = ();

   foreach my $machines (@{ $aref }) {
      $machines =~ s/\s+//go;				# kill whitespace
      foreach (split(',',$machines)) {
	 my @Dash = split('-');
	 if (/^\@(.*)$/) {				# a netgroup
	    if (defined($href->{$1})) {
	       push(@Machines,@{ $href->{$1} });
	    }
	    next;
	 } elsif (! (scalar(@Dash) % 2)) {		# a valid range
	    my $chunkL = my $chunkR = "";		# contains an even
	    while (scalar(@Dash)) {			# number of "things"
	       $chunkL .= shift(@Dash) . '-';		# split by '-'
	       $chunkR = pop(@Dash) . "-$chunkR";
	    }
	    chop($chunkL); chop($chunkR);
	    my $nodeL = $nodeR = undef;
	    my $clusterL = $clusterR = undef;
	    if ($chunkL =~ /\D*(\d+)$/) {		# must end with digits
	       $nodeL = $1;
	       ($clusterL = $chunkL) =~ s/^(.*)$nodeL$/$1/;
	    } else {
	       push(@Machines,$_);
	       next;
	    }
	    if ($chunkR =~ /\D*(\d+)$/) {		# must end with digits
	       $nodeR = $1;
	       ($clusterR = $chunkR) =~ s/^(.*)$nodeR$/$1/;
	    } else {
	       push(@Machines,$_);
	       next;
	    }
	    if ($clusterL ne $clusterR) {		# cluster mismatch
	       push(@Machines,$_);
	       next;
	    } else {
	       if ($nodeL <= $nodeR) {
		  my $fmt = ($nodeL =~ /^0/
		     ? "$clusterL%0".length($nodeL).'d'	# a leading zero
		     : "$clusterL%d"
		  );
		  for (my $i=$nodeL; $i <= $nodeR; $i++) {
		     push(@Machines,sprintf("$fmt",$i));
		  }
	       } else {
		  my $fmt = ($nodeR =~ /^0/
		     ? "$clusterR%0".length($nodeR).'d'	# a leading zero
		     : "$clusterR%d"
		  );
		  for (my $i=$nodeL; $i >= $nodeR; $i--) {
		     push(@Machines,sprintf("$fmt",$i));
		  }
	       }
	    }
	 } elsif (/^all(not)?(down|boot|error|unavailable|up)?$/i) {
	    -x '/usr/bin/bpstat' || (push(@Machines,$_) , next);
	    open(BPSTAT, "bpstat -n $_ |") ||
	       (push(@Machines,$_) , next);
	    foreach my $node (<BPSTAT>) {
	       chop $node;
	       if ($node =~ /^\d+$/) {
		  push(@Machines, $node);
	       }
	    }
	    close BPSTAT;
	 } else {					# a single host
	    push(@Machines,$_) unless (/^$/);
	 }
      }
   }

   my @NoDup = ();
   foreach my $machine (@Machines) {
      next if (grep(/^\Q$machine\E$/,@NoDup));		# weed out duplicates
      if ($opt_V) {
	 unless(defined(gethostbyname($machine))) {	# qualify host
	    warn "$prog: bad hostname '$machine'.\n" if ($opt_v);
	    next;
	 }
      }
      push(@NoDup,$machine);
   }
   return @NoDup;
}

sub tstp_signal_handler {
   my $nal = $_[0];
   ${ "SIG$nal" } = 1;
   return 0;
}

sub handle_sigTSTP {
   my %_RUNpids = %RUNpids;
   my @_MachineList = @MachineList;
   my ($pid, $src, $dst);

   $SIGTSTP = 0;

   format STDERR =
^>>>>>>>>>>>>>>> -> ^<<<<<<<<<<<<<<<  pid=^<<<<<<<<<<<<<<<<
$src,               $dst,                 $pid
.

# processes running
   print STDERR "\n                    Outstanding Processes:\n";
   foreach $pid (sort {$a <=> $b } keys %_RUNpids) {
      $dst = $_RUNpids{$pid}{'machine'};
      $src  = (defined $_RUNpids{$pid}{'sender'}
	 ? $_RUNpids{$pid}{'sender'}
	 : $ThisMachine
      );
      write STDERR;
   }

# processes waiting to run
   my $num = scalar @_MachineList;
   if ($num > $PMAX) {
      print STDERR "\n                    ($num more waiting to run)\n";
   } else {
      foreach $dst (@_MachineList) {
	 $pid = '(waiting to run)';
	 $src = '';
	 write STDERR;
      }
   }

   print STDERR "\n";

}

sub IT_signal_handler {
   my $nal = $_[0];

   local $SIG{$nal} = 'IGNORE';
   kill $nal => -$$;
   unlink($tty) if (-e $tty);
   exit -1;
}

sub __DIE__signal_handler {
   my $error = $_[0];

   unlink($tty) if (-e $tty);
   die $error;
}

# Documentation

=head1 NAME

B<pexec> - execute a command on a set of hosts

=head1 SYNOPSIS

B<pexec> [B<-h>] [B<--man>]

B<pexec> I<args> S<[B<-l> I<user>]> S<[B<-o> I<outfile>]> S<[B<--bpsh>]> S<[B<--rsh>]>
S<[B<--ssh>]> B<cmd>

B<pexec> I<args> S<B<--bpcp>>  S<[B<--bpcp-opts> I<opts>]> B<src> S<[B<src ...>]>
[I<user@>]%host%:B<dest>

B<pexec> I<args> S<B<--rcp>>   S<[B<--rcp-opts> I<opts>]>  B<src> S<[B<src ...>]>
[I<user@>]%host%:B<dest>

B<pexec> I<args> S<B<--scp>>   S<[B<--scp-opts> I<opts>]>  B<src> S<[B<src ...>]>
[I<user@>]%host%:B<dest>

B<pexec> I<args> S<B<--rsync>> S<[B<--rsync-opts> I<opts>]>
S<[B<--rsync-rsh> I<rshell>]> B<src> S<[B<src ...>]> [I<user@>]%host%:B<dest>

where I<args> are one or more of:

=over

S<B<-m> I<host>[I<,host>]> S<[B<-s> I<host>[I<,host>]]> S<[B<-P> [I<#>]]>
S<[B<-dpVv>]> [B<--all>] S<[B<--exit-success> I<rc>[I<,rc>]]>
S<[B<--random>]> S<[B<-t> I<timeout>]>

=back

=head1 DESCRIPTION

B<pexec> builds a machine list from command-line arguments on which an
arbitrary B<cmd> is to be run.  Called in its most general form, B<pexec>
achieves parallelism by overseeing a fixed number of fork(2)'d and
execvp(3)'d B<cmd> processes marshalled by the host initiating the
operation (the execution host).  If the string "I<%host%>" is part of
B<cmd>, names from the machine list are substituted in its stead.

Alternatively specifying one of the remote file copy operations, B<pexec>
fixes B<cmd> appropriately and distributes B<src> to the machine list's
B<dest> in a tree-like fashion: on success (proper exit status), the
destination machine is placed on a work queue to potentially source a
future copy operation itself.  Any source machine and the "root" of the
tree will always be returned to the work queue upon completion of their
subtasks (but see B<-P> below for alternate behavior).  Note here that the
string "I<%host%>" is a mandatory part of the B<dest> description.

The output of B<cmd> on each machine is printed to the execution host's
STDOUT by default (but see B<-o> below for alternate behavior).  B<pexec>
will catch the following signals for special processing: INT (B<^C>), QUIT
(B<^\>), TERM and TSTP (B<^Z>).  B<pexec> will elevate INT and TERM signals
it receives to KILL any children it has spawned, then terminate itself
immediately.  Signalling QUIT (usu. B<^\>) will KILL any children that have
already been spawned by B<pexec>, however execution of the parent
I<proceeds> if there are any hosts remaining in the machine list that have
not had the opportunity to exec something!  Issuing TSTP (B<^Z>) will print
to STDERR the list of outstanding processes B<pexec> has spawned (or plans
to) that await completion, then continue.

=head1 OPTIONS

=over 4

=item B<-h,--help>

Show command usage and exit.

=item B<--man>

Print the pexec(1) manpage and exit.

=item B<-a,--all>

Permit B<cmd> to be run on the execution host if it is specified in the
machine list (skipped by default).

=item B<--bpsh>

Remote B<cmd> execution via bpsh(1) (equivalent to S<"bpsh -n I<%host%>">).

=item B<--bpcp> B<src> [B<src ...>] [I<user@>]%host%:B<dest>

Distribute locally-resident B<src> (file or directory) to remote B<host:dest>
using B<bpcp> for every host in the machine list.  Specifying more than one
B<src> mandates that B<host:dest> be a directory name on the remote machine.
I<User> must have BProc execute permission on every host in the machine
list for successful operation!  Your current I<user> name is assumed if
none is specified.  See the B<CAVEATS> section below if you have an
unpatched B<bpcp> on your system.

=item B<--bpcp-opts> I<opts>

If B<--bpcp> is specified, pass the following I<opts> directly to B<bpcp>.
If this option is omitted, I<opts> defaults to "I<-rp>" (recursive; preserve
mode, ownership and timestamps).

=item B<-d,--debug>

Don't really execute anything, just print to STDOUT the B<cmd> that would
be executed (via execvp(3)) throughout the execution cycle.  The printed
command and its arguments are individually enclosed by single quotes.

=item B<--exit-success> I<rc>[I<,rc>]

Define the successful exit statuses for B<cmd> as comma-separated integer
values.  Note that fan-out for the remote file copy operations is only
accomplished by proper exit status of B<cmd> as it is run by the hosts
which comprise the machine list.  Requesting B<pexec> to run a remote copy
operation via B<--bpcp>, B<--rcp>, B<--rsync> or B<--scp> which succeeds
yet exits with an I<rc> outside this list will result in I<serial>
operation!  On the other hand, cascading failure may ensue if you include a
return code here which really does indicate failure of B<cmd>.  Default
behavior if this option is omitted is to only consider exit status I<0>
indicative of success.

=item B<--fan-out> I<#>

If a remote file copy operation is requested, permit fan-out of B<cmd> to
be sourced by at most I<#> >= 0 hosts from the machine list simultaneously.
If B<--fan-out> is not specified, the default is 256-way parallelism.
Entirely serial operation is accomplished by setting B<--fan-out=0> in which
case no fan-out is performed whatsoever; the source for every remote copy
to all hosts in the machine list will be the execution host itself.

=item B<-l,--login> I<user>

Authenticate as I<user> on the remote machine (only valid with "B<--rsh>" or
"B<--ssh>").

=item B<-m,--machines> I<host>[I<,host>]

Include I<host> in the machine list.  Valid names are hosts, netgroups and
ranges, each of which may be inter-mixed however always comma separated.
Netgroup names are designated with a leading "@" (e.g. "@nirvanas").  Host
ranges are specified with a "-" between valid host names (e.g. "n01-n16").
Multiple instances of B<-m> may be specified.

=item B<-o,--output> I<outfile>

Send the output produced by B<cmd> to I<outfile>.  If the string
"I<%host%>" is part of I<outfile>, names from the machine list are
substituted in its stead.  This option is ignored for the remote file copy
operations.

=item B<-P,--parallel> [I<#>]

Permit parallel execution of B<cmd> by the execution host on I<#> hosts
from the machine list simultaneously.  Generally, if I<#> is not specified,
the default is 32-way parallelism; if B<-P> is omitted altogether, B<cmd> is
executed serially on each machine in the list.

In the case of B<--bpcp>, B<--rcp>, B<--rsync> or B<--scp>, however, if
I<#> is omitted the default is to set B<P=1> and accomplish parallelism by
B<cmd> fan-out (see B<--fan-out> above to limit the width).  Specifying larger
values than I<1> might be desirable to take advantage of additional capabilities
the execution host may possess over others in the machine list (e.g. faster
disk, larger network pipe, etc).  A negative value of I<#> permits the
execution host to initially source B<abs>(I<#>) parallel remote copy
operations but is then omitted from the work queue for future execution.

=item B<-p,--prefix>

Generally, prefix every line of output produced by B<cmd> by S<"I<host>: ">, the
machine on/for which it was run.  Remote file copy specifications get
prefixed by S<"I<server>-E<gt>I<host>: ">.

=item B<--random>

Randomize the machine list instead of honoring the order provided on the
command line.

=item B<--rcp> B<src> [B<src ...>] [I<user@>]%host%:B<dest>

Distribute locally-resident B<src> (file or directory) to remote B<host:dest>
using rcp(1) for every host in the machine list.  Specifying more than one
B<src> mandates that B<host:dest> be a directory name on the remote
machine.  Password-less rsh(1) authentication for I<user> must succeed
between any given pair of hosts in the machine list!  Your current I<user>
name is assumed if none is specified.

=item B<--rcp-opts> I<opts>

If B<--rcp> is specified, pass the following I<opts> directly to rcp(1).
If this option is omitted, I<opts> defaults to "I<-rp>" (recursive; preserve
mode, ownership and timestamps).

=item B<--rsh>

Remote B<cmd> execution via rsh(1) (equivalent to S<"rsh -n I<%host%>">).

=item B<--rsync> B<src> [B<src ...>] [I<user@>]%host%:B<dest>

Distribute locally-resident B<src> (file or directory) to remote B<host:dest>
using rsync(1) for every host in the machine list.  Specifying more than
one B<src> mandates that B<host:dest> be a directory name on the remote
machine.  Password-less ssh(1) authentication for I<user> must succeed
between any given pair of hosts in the machine list (see B<--rsync-rsh>
below for an alternate remote-shell and/or authentication method)!  Your
current I<user> name is assumed if none is specified.

=item B<--rsync-opts> I<opts>

If B<--rsync> is specified, pass the following I<opts> directly to rsync(1).
If this option is omitted, I<opts> defaults to "I<-aq>" (archive; quiet).
Do not specify a remote transport shell with this option (see B<--rsync-rsh>
below)!

=item B<--rsync-rsh> I<rshell>

If B<--rsync> is specified, use I<rshell> as the remote transport shell for
rsync(1).  You can also use B<--rsync-rsh> to authenticate as a different
I<user> on the remote machine (see the B<EXAMPLES> section below).  If this
option is omitted, I<rshell> defaults to "I<ssh -qx>".

=item B<--scp> B<src> [B<src ...>] [I<user@>]%host%:B<dest>

Distribute locally-resident B<src> (file or directory) to remote B<host:dest>
using scp(1) for every host in the machine list.  Specifying more than one
B<src> mandates that B<host:dest> be a directory name on the remote machine.
Password-less ssh(1) authentication for I<user> must succeed between any
given pair of hosts in the machine list!  Your current I<user> name is
assumed if none is specified.

=item B<--scp-opts> I<opts>

If B<--scp> is specified, pass the following I<opts> directly to scp(1).
If this option is omitted, I<opts> defaults to "I<-Brpq>" (batch mode;
recursive; preserve mode, ownership and timestamps; quiet).

=item B<--ssh>

Remote B<cmd> execution via ssh(1) (equivalent to S<"ssh -nx I<%host%>">).

=item B<-s,--skip> I<host>[I<,host>]

Skip I<host> from the machine list.  Valid names are hosts, netgroups and
ranges, each of which may be inter-mixed however always comma separated.
Netgroup names are designated with a leading "@" (e.g. "@nirvanas").  Host
ranges are specified with a "-" between valid host names (e.g. "n01-n16").
Multiple instances of B<-s> may be specified.

=item B<-t,--timeout> I<timeout>

Timeout for execution of B<cmd>.  A value of "0" disables the timeout
(default: 300 sec).

=item B<-V,--verify>

Verify hostnames in the machine list with gethostbyname(3) before executing
B<cmd>.  Invalid hostnames are removed from the machine list.  This option
can increase your time-to-execute significantly.

=item B<-v,--verbose>

Print, on STDOUT, the B<cmd> issued to each I<host>, followed by its
output, if any.

=head1 EXAMPLES

1)  % pexec -P 128 -m rp1-rp128 -t 5 --ssh uptime

Remotely execute (by ssh(1)) C<uptime>, in 128-way parallel, on rp1, rp2,
..., rp128, killing processes that do not run to completion in 5 seconds.
If B<-v> were specified, each host's output would be separated by the
execution line issued to that particular host.  If B<-p> were specified,
each host's output would be prefixed by its hostname from the machine list.

2)  % pexec -vPt 30 -m @every-host -o %host%.pub ssh-keyscan %host%

Retrieve, in 32-way (default) parallel, remote hosts' public rsa1 keys,
storing the result in %host%.pub, which is set individually for each
machine defined by netgroup @every-host.  Kill processes that have not
completed in 30 seconds.

3)  % pexec -vPt 10 -m @FC5 -s mailhost,@nameservers --rsh "init 0"

Remotely halt (by rsh(1)), in 32-way (default) parallel, all hosts defined
by the netgroup "FC5", skipping "mailhost" and all hosts defined by
netgroup "nameservers".  Kill processes that have not completed in 10
seconds.

4a)  % pexec -t 60 -m n0-n1023 -P 6 --rsync --rsync-rsh "rsh -l root"
/net/scratch/data %host%:/tmp/.

4b)  % pexec -t 60 -m n0-n1023 -P 6 --rsync --rsync-rsh rsh
/net/scratch/data root@%host%:/tmp/.

4c)  % pexec -t 60 -m n0-n1023 -P 6 rsync -aq -e rsh /net/scratch/data
root@%host%:/tmp/.

Remote archive copy, by rsync(1), C</net/scratch/data> to C</tmp/data> of
n0, n1, ..., n1023.  Authentication between hosts will be accomplished by
rsh(1) access for the root user.  At any given time, there may be up to six
rsync(1) instances sourced from the execution host itself.  Examples 4a)
and 4b) permit up to 256 individual rsync(1) processes sourced by the
"leaves" of the execution tree whereas the general-case example 4c) permits
none.  Kill processes that do not run to completion in 60 seconds.


=head1 DIAGNOSTICS

B<pexec> exits with 0 on success.  On B<cmd> failure, the exit value will
be determined by the logical OR of all of the I<improper> statuses returned
by B<cmd> running on the machine list.  See B<--exit-success> for a
mechanism to influence what B<pexec> believes to be success/failure of
B<cmd>.

=head1 ENVIRONMENT

=over 6

=item B<PEXEC>

Take B<pexec> options from this environment variable, which is parsed
before the command line (and thereby overridden).

=back

=head1 FILES

F</etc/netgroup>

=head1 CAVEATS

1. When distributing a I<single> B<src> to B<host:dest>, it is infeasible for
B<pexec> to ascertain whether the destination is a I<file> or a
I<directory> name on the remote host; an important fact to know for the
"leaves" of the tree to source B<cmd> on other hosts in the machine list.
If B<host:dest> I<should be> a directory name, include a trailing slash
("/" or "/.") in its discription.  Omitting this, B<pexec> will attempt to
answer the question by investigating the execution host's filesystem
itself, however it is not at all required to look like the filesystems of
the machine list.  Failing all of the above, B<pexec> will treat B<dest> as
a I<file>name on the remote host.

2. Emperical data shows that rcp(1) and 'rsh(1) B<cmd>' do not exit with
non-zero status on failure of their execution.  The most robust of the
remote copy operations in this regard are rsync(1) and scp(1).

3. Many (all?) released versions of B<bpcp> to date do not wait(2) for forked
processes during 3rd party copies (remote to remote).  Being a derivative
of rcp(1), exit status is often not set properly so B<pexec> proceeds
happily; your B<src> appears to be copied successfully to B<host:dest> in a
matter of seconds regardless of cluster size!  If you received this code
as part of an RPM package, a patch to fix B<bpcp> resides in your
distribution's %docdir.

4. If you time out on a remote operation, the local process that transported you
will terminate but any successful remote execution may proceed!

=head1 REMOTE FILE COPY RESTRICTIONS

1. It is assumed that password-less authentication as required by B<cmd> will
succeed between any pair of hosts in the machine list for I<user>.  It is
also vacuously required that the execution host have the same privilege to
any host in the machine list, however the converse need not be true for
B<pexec> to succeed.

2. Filesystem uniformity must exist between all hosts in the machine list
with regard to B<dest>:  if B<dest> is a directory name on the filesystems
of some machines and not on others, B<pexec> will certainly fail.

3. B<pexec> does not check the validity any of the options specified by
B<--bpcp-opts>, B<--rcp-opts>, B<--scp-opts>, B<--rsync-opts> or
B<--rsync-rsh>; use with caution.

=head1 SEE ALSO

gethostbyname(3), I<bpcp -h>, bpsh(1), netgroup(5), rsh(1), rcp(1),
rsync(1), ssh(1), scp(1)

=head1 AUTHOR

Daryl W. Grunau <dwg@lanl.gov>

=head1 COPYRIGHT AND LICENSE

Copyright 2007 by Daryl W. Grunau

This program is free software; you can redistribute it and/or
modify it under the terms of the GNU General Public License
as published by the Free Software Foundation; either version 2
of the License, or (at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.

This program has been approved for release from Los Alamos National
Laboratory by LA-CC Number xx-xxx, and authored by an employee of the
University of California, operator of the Los Alamos National Laboratory
under Contract No. W-7405-ENG-36 with the U.S. Department of Energy.

=cut
