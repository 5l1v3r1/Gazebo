#!/bin/tcsh

# Find Common Errors
# Utility used to search for commonly seen errors in any file in the log directory.
# This is somewhat fluid and will probably vary from one platform to the next.

# input: none, need to edit dates currently
# output: files placed in GHOME corresponding to each date searched 
#  containing separate lines of the form "jobId reason-string"


# code starts searching at the top level of the day in the results directory specified by date 
# something like : /home/gazebo/atc-results-must/gzshared/2011/2011-08/2011-08-26

# work to do...
# 1) get result dir from gazebo.conf
# 2) handle dates as input instead of editing file
# 3) possibly replace findgrep with "grep -r". findgrep is nice, but not everywhere



set mo = "11" 
set yr = "2011"

foreach da ( 18 19 20 21 )

  cd /home/gazebo/atc-results-caddy/gzshared/${yr}/${yr}-${mo}/${yr}-${mo}-${da}

  set outfile = ${GZHOME}/comErrs.${yr}-${mo}-${da}
  echo "Writing $outfile"

  echo "# JobId Reason" > ${outfile}

 /usr/bin/findgrep . -c "RETRY EXCEEDED ERROR" | awk '{if (NF==1) {jobid=$1} else if (NF>1) {printf ("%s %s to %s\n", jobid, $4, $6)}}' | grep "localdomain to mu" | sort -n | uniq | awk -F '.' '{printf("%s %s %s\n", $2, $(NF-1), $NF)}' | awk '{split( $1, a, "__") ; printf("%s Retry Exceeded Error to %s\n",  a[3], $6)}' | uniq > ${outfile}

  /usr/bin/findgrep . -c "TIME LIMIT" | sort -n | awk -F '.' '{printf("%s\n", $2)}' | awk '{split( $1, a, "__") ; if ( NF > 0 ) printf("%s Time Limit Exceeded\n",  a[3] )}' >> ${outfile}

  /usr/bin/findgrep . -c  "CANCELLED AT" | sort -n | awk -F '.' '{printf("%s\n", $2)}' | awk '{split( $1, a, "__") ; if ( NF > 0 ) printf("%s Job canceled by admin\n",  a[3] )}' >> ${outfile}

  /usr/bin/findgrep . "FAIL: below" | uniq | sort -n | awk -F '.' '{printf("%s\n", $2)}' | awk '{split( $1, a, "__") ; printf("%s HPL below efficiency minimum of 50%%\n",  a[3] )}'  >> ${outfile}

  /usr/bin/findgrep -c "mca_oob_tcp_msg" | awk '{if (NF==1) {jobid=$1} else if (NF>1) {split( $2, a, ".") ; printf ("%s %s %s %s %s\n", jobid, $4, $5, $6,  a[1])}}' |  awk '{split( $1, a, "__") ; printf("%s %s %s %s %s\n", a[3], $2, $3, $4, substr( $5, 2 ) )}'  | uniq >> ${outfile}

  findgrep -c "NODE FAILURE" | awk '{if (NF==1) {jobid=$1} else if (NF>1) {split( $2, a, ".") ; printf ("%s %s %s %s %s\n", jobid, $4, $5, $6,  a[1])}}' | awk '{split( $1, a, "__") ; printf("%s %s due to node failure at %s\n", a[3], $4, substr( $5, 8, 6 ) )}' | sort -n | uniq  >> ${outfile}

  /usr/bin/findgrep . -c "daemon did not report back when launched" | awk '{if (NF==1) {jobid=$1} else if (NF>1) {printf ("%s %s\n", jobid, $2 )}}' | awk '{split( $1, a, "__") ; printf("%s mpi daemon did not report back when launched %s\n", a[3], $2  )}' | sort -n | uniq >> ${outfile}

  /usr/bin/findgrep . -c "EXECUTABLE EXPIRED" | awk '{if (NF==1) {jobid=$1} else if (NF>1) {printf ("%s %s %s\n", jobid, $2, $3)}}' | sort -n | uniq | awk -F '.' '{printf("%s %s %s\n", $2, $(NF-1), $NF)}' | awk '{split( $1, a, "__") ; printf("%s %s %s\n",  a[3], $4, "license expired") }' | uniq >> ${outfile}

  /usr/bin/findgrep -c "joblogfile missing" | awk '{if (NF==1) {jobid=$1} else if (NF>1) {split( $2, a, ".") ; printf ("%s %s %s %s %s\n", jobid, $4, $5, $6,  a[1])}}' | awk '{split( $1, a, "__") ; printf("%s %s %s\n", a[3], $2, $3 )}'  | uniq >> ${outfile}

  /usr/bin/findgrep -c "PSM EP connect" | awk '{if (NF==1) {jobid=$1} else if (NF>1) {split( $2, a, ".") ; printf ("%s %s %s %s %s\n", jobid, $4, $5, $6,  a[1])}}' | awk '{split( $1, a, "__") ; printf("%s %s\n", a[3], "PSM EP connect error")}' | uniq >> ${outfile}

end

exit
